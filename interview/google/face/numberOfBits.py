"""
题目是给一个positive integer N，求N最少能由几个2^i组成。比如N=1的时候，1=2^0，那么N最少能被1个2^0组成。
再比如N=7的时候，7=4+2+1=2^2+2^1+2^0，这个case中N最少被3个2^i组成。然后follow up是，可以同时使用正或负的2^i。
同样的例子N=7，在这个情况下，7=8-1=2^3-2^0，这样最少只需要2个2^i就能组成N。
"""
"""
你的思路跟我挺像的，不過你用+1 -1來說明，我想很難讓大家看懂。這題的關鍵在於可以用+1把多個1，ˊ轉化成兩個1。
假設你有一個數是111...1 (n個1)，原本的表示法需要用n個2^x來表示，但是+1之後，數字變成了1000...0 (1個1後面帶n個0)，
只需要1個2^x表示，加上你要把多加的1 (2^0) 扣回去，所以原數字可以用兩個2^x表示。-1並不是很必要，反正right shift都會被吃掉。

思路：. more info on 1point3acres.com
一開始count = 0
看least significant bit. 鐗涗汉浜戦泦,涓€浜╀笁鍒嗗湴
->是0忽略
->是1的話，count++，然後往左看有無連續1 (實際上看左邊一位就行)
    ->左邊是1，+1讓他進位
    ->左邊是0忽略
往右shift一個bit，重複上述步驟ˋ直到number變成0

實際上遇到1個1就count++，為什麼呢？假如這個1是單獨的，那麼我們必定要用一個2^x表示它。假如是連續的，那麼如上面所說，
我們可以用+1進位後，用兩個2^x來表示，這邊count++是先算你多加的1 (2^0)，另外一個1因為被你進位跑去左邊了，
所以之後遇到他會是單獨的1，到時候你還是會算到他，所以總共是兩個1。
"""
a = int("111000000011", 2)
count = 0
while a != 0:
    if a & 1 == 0:
        a >>= 1
    else:
        a >>= 1
        count += 1
        if a & 1 == 1:
            while a & 1 == 1:
                a >>= 1
            count += 1
print(count)  